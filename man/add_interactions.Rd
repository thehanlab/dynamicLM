% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_interactions.R
\name{add_interactions}
\alias{add_interactions}
\title{Add landmarking time interactions to a super dataset}
\usage{
add_interactions(lmdata, lm_covs, func_covars, func_lms, lm_col, keep = TRUE)
}
\arguments{
\item{lmdata}{An object of class "LMdataframe".

This can be created by running \code{\link[=stack_data]{stack_data()}}, or creating a
stacked data set and storing it in a list with attributes outcome, w and
end_time (see \code{\link[=stack_data]{stack_data()}} for further description of outcome
and w), end_time is the largest landmarking time.}

\item{lm_covs}{Vector of strings indicating the columns (covariates) that are
to have an interaction with the landmark times.}

\item{func_covars}{Either a string/vector of strings or list of
functions specifying which covariate-landmark interactions to include.
If \code{x} are covariates and \code{t} are landmarks then "linear" (\verb{x, x*t}),
"quadratic" (\verb{x, x*t^2}), "log" (\verb{x, log(1 + x)}), or or "exp"
(\verb{x, exp(x)}) can be specified.

A custom list of functions can be specified. For example,
\code{list(function(t) t, function(t) exp(20*t))} will, for each covariate,
create \verb{x, x*t, exp(20*t)}.}

\item{func_lms}{A list of functions to use for transformations of the
landmark times input similarly to \code{func_covars}, either as a string/
vector of strings or a custom list of functions.}

\item{lm_col}{Character string specifying the column name that indicates the
landmark time point for a row. Obtained from \code{lmdata} if not input.}

\item{keep}{Boolean value to indicate whether or not to keep the columns
given by \code{lm_covs} without the time interactions. Default is TRUE.}
}
\value{
An object of class "LMdataframe" which now also contains LM
time-interactions.
The object has the following components:
\itemize{
\item w, outcome: as the input (obtained from lmdata)
\item func_covars: as the input
\item func_lms: as the input
\item lm_covs: as the input
\item all_covs: a list of the new columns added. This includes \code{lm_covs}
if \code{keep} is TRUE.
\item lm_col: as the input
}
}
\description{
The stacked dataset output is used as input to \code{\link[=dynamic_lm]{dynamic_lm()}} to fit a landmark
supermodel for dynamic prediction.
}
\details{
For each variable "var" in \code{lm_covs}, new columns var_1,...,var_i
(length(func_covars) == i) are added; one column for each interaction given
in func_covars is added.

Transformations of the LM column are added and labelled as LM_1,...,LM_j
(length(func_lms) == j); one column for each interaction given in func_lms
is added.
}
\examples{
\dontrun{
data(relapse)
outcome <- list(time = "Time", status = "event")
covars <- list(fixed = c("age.at.time.0", "male", "stage", "bmi"),
               varying = c("treatment"))
w <- 60; lms <- c(0, 6, 12, 18)
# Choose covariates that will have time interaction
pred_covars <- c("age", "male", "stage", "bmi", "treatment")
# Stack landmark datasets
lmdata <- stack_data(relapse, outcome, lms, w, covars, format = "long",
                     id = "ID", rtime = "T_txgiven")
# Update complex landmark-varying covariates
# note age is in years and LM is in months
lmdata$data$age <- lmdata$data$age.at.time.0 + lmdata$data$LM/12
# Add LM-time interactions
lmdata <- add_interactions(lmdata, pred_covars,
                           func_covars = c("linear", "quadratic"),
                           func_lms = c("linear", "quadratic"))
head(lmdata$data)
}

}
